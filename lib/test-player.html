<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YouTube-Style Stream Test</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 50px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      h1 {
        color: #333;
      }
      .controls {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      input,
      button {
        padding: 10px;
        margin: 5px;
        font-size: 14px;
      }
      button {
        background: #1976d2;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover {
        background: #1565c0;
      }
      video {
        width: 100%;
        max-width: 800px;
        background: #000;
        border-radius: 8px;
      }
      .log {
        background: #263238;
        color: #aed581;
        padding: 15px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        margin-top: 20px;
      }
      .log div {
        margin: 5px 0;
      }
      .error {
        color: #ff5252;
      }
      .success {
        color: #69f0ae;
      }
      .info {
        color: #40c4ff;
      }
    </style>
  </head>
  <body>
    <h1>üé¨ YouTube-Style Streaming Test</h1>

    <div class="controls">
      <input type="text" id="tmdbId" placeholder="TMDB ID" value="550" />
      <input type="text" id="apiUrl" placeholder="Backend URL" value="http://localhost:3000" />
      <button onclick="playStream()">‚ñ∂Ô∏è Play Stream</button>
    </div>

    <video id="video" controls></video>

    <div class="log" id="log"></div>

    <script>
      let hls = null;

      function log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = type;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(message);
      }

      /**
       * Decrypt AES-256-CBC encrypted URL
       */
      function decryptUrl(encryptedUrl, key) {
        try {
          // Split IV and encrypted data
          const parts = encryptedUrl.split(':');
          const iv = CryptoJS.enc.Base64.parse(parts[0]);
          const encrypted = parts[1];

          // Convert hex key to WordArray
          const keyWordArray = CryptoJS.enc.Hex.parse(key);

          // Decrypt
          const decrypted = CryptoJS.AES.decrypt(encrypted, keyWordArray, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7,
          });

          return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (error) {
          log(`‚ùå Decryption error: ${error.message}`, 'error');
          throw error;
        }
      }

      async function playStream() {
        const tmdbId = document.getElementById('tmdbId').value;
        const apiUrl = document.getElementById('apiUrl').value;

        log('üîê Getting JWT token...', 'info');

        try {
          // Step 1: Get JWT token
          const authResponse = await fetch(`${apiUrl}/auth/session`, {
            method: 'POST',
          });
          const { token } = await authResponse.json();
          log('‚úÖ JWT token obtained', 'success');

          // Step 2: Request stream
          log(`üé¨ Requesting stream for TMDB ${tmdbId}...`, 'info');
          const streamResponse = await fetch(`${apiUrl}/stream/movie/${tmdbId}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!streamResponse.ok) {
            throw new Error(`HTTP ${streamResponse.status}`);
          }

          const data = await streamResponse.json();
          log(`‚úÖ Session created: ${data.sessionId}`, 'success');
          log(`üìã Manifest URL: ${data.manifestUrl}`, 'info');
          log(`üöÄ Cloudflare will fetch & cache playlist`, 'info');

          // Step 3: Load manifest URL directly into HLS.js
          // Cloudflare handles playlist fetching, parsing, and segment serving
          const video = document.getElementById('video');

          if (Hls.isSupported()) {
            if (hls) {
              hls.destroy();
            }

            hls = new Hls({
              debug: false,
              enableWorker: true,
            });

            log('üé• Loading manifest from Cloudflare...', 'info');
            hls.loadSource(data.manifestUrl);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
              log('‚úÖ Manifest parsed successfully!', 'success');
              log('üé¨ Starting playback...', 'info');
              video.play().catch((e) => log(`‚ö†Ô∏è Autoplay blocked: ${e.message}`, 'error'));
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
              if (data.fatal) {
                log(`‚ùå Fatal error: ${data.type} - ${data.details}`, 'error');
                switch (data.type) {
                  case Hls.ErrorTypes.NETWORK_ERROR:
                    log('üîÑ Trying to recover from network error...', 'info');
                    hls.startLoad();
                    break;
                  case Hls.ErrorTypes.MEDIA_ERROR:
                    log('üîÑ Trying to recover from media error...', 'info');
                    hls.recoverMediaError();
                    break;
                  default:
                    log('üí• Cannot recover, destroying HLS instance', 'error');
                    hls.destroy();
                    break;
                }
              } else {
                log(`‚ö†Ô∏è Non-fatal error: ${data.details}`, 'error');
              }
            });

            hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
              log(`üì¶ Segment ${data.frag.sn} loaded (${data.frag.duration.toFixed(1)}s)`, 'success');
            });
          } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            log('üçé Using native HLS support', 'info');
            video.src = data.manifestUrl;
            video.play();
          } else {
            log('‚ùå HLS not supported in this browser', 'error');
          }
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
        }
      }
    </script>
  </body>
</html>
